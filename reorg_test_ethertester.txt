#!/usr/bin/env python3
"""
reorg_test_ethertester.py

Simulate a chain reorg against two contracts (SecureAuction and VulnAuction)
using web3.py + EthereumTester (evm_snapshot / evm_revert / evm_mine).

Requirements:
 - python3
 - web3 (pip install web3)
 - eth-tester (pip install eth-tester[py-evm])
 - eth-utils (pip install eth-utils)
 - Foundry installed (forge in PATH) because this script calls `forge build`
   to compile contracts and produce artifact JSON files in `out/`.

How it works:
 1. `forge build` is run to ensure artifacts are fresh.
 2. The script reads out/SecureAuction.json and out/VulnAuction.json for ABI+bytecode.
 3. Deploy both contracts with requiredConfirmations = 3.
 4. Use accounts: deployer, honest, malicious, miner (from EthereumTester)
 5. Commit phase (both bidders commit). Take snapshot AFTER commits (this is the fork point).
 6. Branch A: include both reveals -> mine confirmations -> finalize -> record winner/state.
 7. Revert to snapshot (this removes branch A reveals).
 8. Branch B: only honest reveals (or alternate reveals) -> mine confirmations -> finalize -> record winner/state.
 9. Compare winners for Secure vs Vuln to show divergence.

Note: this script assumes Foundry's compile output files are located at `out/<ContractName>.json`.
If your project layout differs, adjust the artifact paths accordingly.
"""

import json
import subprocess
import time
from pathlib import Path
from web3 import Web3
from web3.providers.eth_tester import EthereumTesterProvider
from eth_utils import to_hex
from eth_tester import EthereumTester, PyEVMBackend

PROJECT_ROOT = Path(__file__).resolve().parents[1]  # repo root (adjust if different)
OUT_DIR = PROJECT_ROOT / "out"

SECURE_ARTIFACT = Path("out/SecureAuction.sol/SecureAuction.json")
VULN_ARTIFACT   = Path("out/VulnAuction.sol/VulnAuction.json")

AUCTION_ID = 1
REQUIRED_CONFIRMATIONS = 3  # will pass to constructor; tests also read from contract
GAS = 6_000_000

eth_tester = EthereumTester(PyEVMBackend())
# Helper: run forge build
def forge_build():
    print("üî® Running `forge build` to compile contracts...")
    proc = subprocess.run(["forge", "build"], cwd=PROJECT_ROOT, capture_output=True, text=True)
    if proc.returncode != 0:
        print(" forge build failed. stdout/stderr:")
        print(proc.stdout)
        print(proc.stderr)
        raise RuntimeError("forge build failed")
    print(" forge build finished.")

# Helper: load artifact
def load_artifact(path: Path):
    if not path.exists():
        raise FileNotFoundError(f"Artifact not found: {path}\nRun `forge build` first.")

    with open(path, "r") as f:
        data = json.load(f)

    abi = data.get("abi") or data.get("output", {}).get("abi")

    # Extract bytecode string safely
    bytecode = None
    if isinstance(data.get("bytecode"), dict):
        bytecode = data["bytecode"].get("object")
    elif isinstance(data.get("bytecode"), str):
        bytecode = data["bytecode"]
    elif isinstance(data.get("deployedBytecode"), dict):
        bytecode = data["deployedBytecode"].get("object")
    elif isinstance(data.get("deployedBytecode"), str):
        bytecode = data["deployedBytecode"]
    elif isinstance(data.get("output"), dict):
        # fallback for nested output
        for file, contracts in data["output"].get("contracts", {}).items():
            for name, co in contracts.items():
                if name in path.stem:
                    bytecode = co.get("evm", {}).get("bytecode", {}).get("object")
                    abi = co.get("abi", abi)
                    break

    if not abi:
        raise ValueError(f"ABI not found in artifact {path}")
    if not bytecode:
        raise ValueError(f"Bytecode not found in artifact {path}")

    return abi, bytecode

# Helper: solidity keccak matching Solidity's keccak256(abi.encodePacked(...))
def solidity_keccak(types, values):
    return Web3.solidity_keccak(types, values)

def evm_snapshot(w3: Web3):
    resp = w3.provider.make_request("evm_snapshot", [])
    return resp["result"]

def evm_revert(w3: Web3, snap_id):
    resp = w3.provider.make_request("evm_revert", [snap_id])
    return resp["result"]

def evm_mine(w3: Web3, n=1):
    for _ in range(n):
        w3.provider.make_request("evm_mine", [])

def main():
    forge_build()

    # Load artifacts
    abi_secure, bytecode_secure = load_artifact(SECURE_ARTIFACT)
    abi_vuln, bytecode_vuln = load_artifact(VULN_ARTIFACT)
    print("Loaded artifacts.")

    # Setup web3 + eth-tester (py-evm)
    w3 = Web3(EthereumTesterProvider())
    eth_tester = w3.provider.ethereum_tester
    assert w3.is_connected()

    accounts = w3.eth.accounts
    deployer = accounts[0]
    honest = accounts[1]
    malicious = accounts[2]
    miner = accounts[3]

    print(f"Accounts: deployer={deployer}, honest={honest}, malicious={malicious}, miner={miner}")

    # Fund accounts if necessary: with EthereumTester, accounts already have balance.

    # Construct contract factories
    Secure = w3.eth.contract(abi=abi_secure, bytecode=bytecode_secure)
    Vuln = w3.eth.contract(abi=abi_vuln, bytecode=bytecode_vuln)

    # Deploy both contracts (requiredConfirmations constructor arg)
    print(f"üì¶ Deploying SecureAuction with requiredConfirmations={REQUIRED_CONFIRMATIONS}...")
    tx_hash = Secure.constructor(REQUIRED_CONFIRMATIONS).transact({"from": deployer, "gas": GAS})
    tx_receipt = w3.eth.wait_for_transaction_receipt(tx_hash)
    secure_addr = tx_receipt.contractAddress
    secure = w3.eth.contract(address=secure_addr, abi=abi_secure)
    print(" SecureAuction at", secure_addr)

    print(f"üì¶ Deploying VulnAuction with requiredConfirmations={REQUIRED_CONFIRMATIONS}...")
    tx_hash = Vuln.constructor(REQUIRED_CONFIRMATIONS).transact({"from": deployer, "gas": GAS})
    tx_receipt = w3.eth.wait_for_transaction_receipt(tx_hash)
    vuln_addr = tx_receipt.contractAddress
    vuln = w3.eth.contract(address=vuln_addr, abi=abi_vuln)
    print(" VulnAuction at", vuln_addr)

    # Short helper to print winner
    def get_winner(contract):
        try:
            return contract.functions.winnerOf(AUCTION_ID).call()
        except Exception as e:
            return None

    # Precompute salts and commits
    salt_honest = Web3.keccak(text="salt_honest_42")
    salt_mal = Web3.keccak(text="salt_malicious_99")
    honest_bid = 100
    mal_bid = 150

    honest_commit = solidity_keccak(['uint256','bytes32'], [honest_bid, salt_honest])
    mal_commit = solidity_keccak(['uint256','bytes32'], [mal_bid, salt_mal])


    # -------------------------
    # Commit phase (on canonical chain prior to snapshot)
    # -------------------------
    print("\n--- Commit phase (both actors commit) ---")
    tx = secure.functions.commit(AUCTION_ID, honest_commit).transact({"from": honest, "gas": GAS})
    w3.eth.wait_for_transaction_receipt(tx)
    tx = secure.functions.commit(AUCTION_ID, mal_commit).transact({"from": malicious, "gas": GAS})
    w3.eth.wait_for_transaction_receipt(tx)

    # Also commit to vulnerable contract (same flow)
    tx = vuln.functions.commit(AUCTION_ID, honest_commit).transact({"from": honest, "gas": GAS})
    w3.eth.wait_for_transaction_receipt(tx)
    tx = vuln.functions.commit(AUCTION_ID, mal_commit).transact({"from": malicious, "gas": GAS})
    w3.eth.wait_for_transaction_receipt(tx)

    print("Commits included on-chain. Current block:", w3.eth.block_number)

    try:
        ok = eth_tester.revert(snapshot_id)
        if not ok:
            print("evm_revert failed ‚Äî snapshot invalid, retrying with new snapshot.")
            snapshot_id = eth_tester.snapshot()
    except Exception as e:
        print(f"evm_revert raised: {e}, taking a new snapshot.")
        snapshot_id = eth_tester.snapshot()

    # Snapshot the chain now ‚Äî this will be the fork point for the reorg.
    snapshot_id = w3.provider.make_request("evm_snapshot", [])["result"]  
    print(f"Baseline snapshot taken: {snapshot_id}")

    # -------------------------
    # Branch A (include both reveals) => finalize (expected Bob/Malicious wins)
    # -------------------------
    print("\n=== Branch A (both reveal) ===")
    # Reveal on secure
    tx = secure.functions.reveal(AUCTION_ID, honest_bid, salt_honest).transact({"from": honest, "gas": GAS})
    r = w3.eth.wait_for_transaction_receipt(tx)
    honest_reveal_block_secure = r.blockNumber
    tx = secure.functions.reveal(AUCTION_ID, mal_bid, salt_mal).transact({"from": malicious, "gas": GAS})
    r = w3.eth.wait_for_transaction_receipt(tx)
    mal_reveal_block_secure = r.blockNumber

    # Reveal on vuln
    tx = vuln.functions.reveal(AUCTION_ID, honest_bid, salt_honest).transact({"from": honest, "gas": GAS})
    w3.eth.wait_for_transaction_receipt(tx)
    tx = vuln.functions.reveal(AUCTION_ID, mal_bid, salt_mal).transact({"from": malicious, "gas": GAS})
    w3.eth.wait_for_transaction_receipt(tx)

    print("Reveals included on branch A. Blocks:", w3.eth.block_number)
    print("Secure reveal blocks: honest", honest_reveal_block_secure, "mal", mal_reveal_block_secure)

    print("Branch A completed ‚Äî ready to simulate reorg.")

    # Attempt premature finalize (should fail for secure due to confirmations; vuln may succeed)

    def safe_revert(snapshot_id):  
        res = w3.provider.make_request("evm_revert", [snapshot_id])  
        if not res["result"]:  
            print("evm_revert failed ‚Äî snapshot invalid. Taking new baseline snapshot.")  
            snapshot_id = w3.provider.make_request("evm_snapshot", [])["result"]  
        return snapshot_id  

    snapshot_id = safe_revert(snapshot_id)  
    print(f"üîÅ Reverted to snapshot {snapshot_id} ‚Äî starting branch B")  


    try:
        print("Attempting immediate finalize on SecureAuction (should fail)...")
        secure.functions.finalizeWithCandidates(AUCTION_ID, [honest, malicious]).transact({"from": miner, "gas": GAS})
        print(" Unexpected: SecureAuction allowed premature finalize")
    except Exception as e:
        print(" SecureAuction premature finalize reverted as expected:", str(e).splitlines()[0])

    try:
        print("Attempting immediate finalize on VulnAuction (may succeed)...")
        tx = vuln.functions.finalizeWithCandidates(AUCTION_ID, [honest, malicious]).transact({"from": miner, "gas": GAS})
        w3.eth.wait_for_transaction_receipt(tx)
        vuln_winner_after_premature = get_winner(vuln)
        print(" VulnAuction finalized prematurely, winner:", vuln_winner_after_premature)
    except Exception as e:
        print("VulnAuction premature finalize reverted (unexpected maybe):", e)

    # Branch B (alternate reveal simulation)
    honest_reveal_block = w3.eth.block_number + 1  
    malicious_reveal_block = None  

    # Mine blocks to simulate passage of time / confirmations
    w3.provider.make_request("evm_mine", [])  
    w3.provider.make_request("evm_mine", [])  

    # Maintain deterministic confirmation behavior
    requiredConfirmations = 3  
    current_block = w3.eth.block_number  
    while current_block - honest_reveal_block < requiredConfirmations:  
        w3.provider.make_request("evm_mine", [])  
        current_block = w3.eth.block_number  


    # Now finalize both (secure should succeed now)
    print("Finalizing SecureAuction on branch A...")
    tx = secure.functions.finalizeWithCandidates(AUCTION_ID, [honest, malicious]).transact({"from": miner, "gas": GAS})
    w3.eth.wait_for_transaction_receipt(tx)
    winner_secure_A = get_winner(secure)
    print("SecureAuction winner on branch A:", winner_secure_A)

    print("Finalizing VulnAuction on branch A (if not already)...")
    try:
        tx = vuln.functions.finalizeWithCandidates(AUCTION_ID, [honest, malicious]).transact({"from": miner, "gas": GAS})
        w3.eth.wait_for_transaction_receipt(tx)
    except Exception:
        pass
    winner_vuln_A = get_winner(vuln)
    print("VulnAuction winner on branch A:", winner_vuln_A)

    # Save stateA for later comparison
    stateA = {
        "secure_winner": winner_secure_A,
        "vuln_winner": winner_vuln_A,
        "block_number": w3.eth.block_number
    }

    # -------------------------
    # Reorg: revert to snapshot (removes branch A reveals + finalization)
    # -------------------------
    print("\nüîÅ Reverting to snapshot to simulate reorg (this orphaned branch A)...")
    ok = evm_revert(w3, snap_id)
    if not ok:
        raise RuntimeError("evm_revert failed")
    print("Reverted. Current block:", w3.eth.block_number)

    # After revert, the chain state is as it was immediately after commits (no reveals).
    # Now create branch B where only honest reveals (malicious reveal is not included).
    print("\n=== Branch B (only honest reveals) ===")
    # Reveal for secure (only honest)
    tx = secure.functions.reveal(AUCTION_ID, honest_bid, salt_honest).transact({"from": honest, "gas": GAS})
    r = w3.eth.wait_for_transaction_receipt(tx)
    honest_reveal_block_secure_B = r.blockNumber

    # For vuln, same
    tx = vuln.functions.reveal(AUCTION_ID, honest_bid, salt_honest).transact({"from": honest, "gas": GAS})
    r = w3.eth.wait_for_transaction_receipt(tx)
    honest_reveal_block_vuln_B = r.blockNumber

    print("Branch B reveals included. Current block:", w3.eth.block_number)
    print("Secure reveal block (B):", honest_reveal_block_secure_B)

    # Advance confirmations on branch B
    print(f"Advancing {REQUIRED_CONFIRMATIONS} blocks on branch B...")
    evm_mine(w3, REQUIRED_CONFIRMATIONS)

    # Finalize both on branch B
    print("Finalizing SecureAuction on branch B...")
    try:
        tx = secure.functions.finalizeWithCandidates(AUCTION_ID, [honest, malicious]).transact({"from": miner, "gas": GAS})
        w3.eth.wait_for_transaction_receipt(tx)
    except Exception as e:
        print("Secure finalize on branch B failed (no confirmed reveals?):", e)

    winner_secure_B = get_winner(secure)
    print("SecureAuction winner on branch B:", winner_secure_B)

    print("Finalizing VulnAuction on branch B...")
    try:
        tx = vuln.functions.finalizeWithCandidates(AUCTION_ID, [honest, malicious]).transact({"from": miner, "gas": GAS})
        w3.eth.wait_for_transaction_receipt(tx)
    except Exception as e:
        print("Vuln finalize on branch B error:", e)
    winner_vuln_B = get_winner(vuln)
    print("VulnAuction winner on branch B:", winner_vuln_B)

    # -------------------------
    # Compare outcomes
    # -------------------------
    print("\n=== Comparison Summary ===")
    print("Branch A (before reorg): secure_winner=", stateA["secure_winner"], "vuln_winner=", stateA["vuln_winner"])
    print("Branch B (after reorg):  secure_winner=", winner_secure_B, "vuln_winner=", winner_vuln_B)

    # Interpret results:
    diverged_secure = (stateA["secure_winner"] != winner_secure_B)
    diverged_vuln = (stateA["vuln_winner"] != winner_vuln_B)

    print("\nInterpretation:")
    if diverged_secure:
        print(" - SecureAuction changed winner after reorg (OK if it recomputed according to canonical chain).")
    else:
        print(" - SecureAuction did NOT change winner after reorg (could indicate finalize persisted orphaned state).")

    if diverged_vuln:
        print(" - VulnAuction changed winner after reorg (this may be expected given the reorg),")
        print("   but check whether the change matches canonical branch B state. If VulnAuction retained the")
        print("   branch A winner after revert, that indicates vulnerability.")
    else:
        print(" - VulnAuction did NOT change winner after reorg (possible persistent incorrect finalization).")

    # Final explicit checks (fail-fast)
    # For secure, we expect final winner to be 'honest' under branch B (since only honest revealed).
    if winner_secure_B.lower() == honest.lower():
        print(" SecureAuction final winner matches canonical branch B (honest).")
    else:
        print(" SecureAuction final winner does NOT match canonical branch B (unexpected).")

    # For vuln, vulnerability manifests as it finalizing to malicious on branch A but not updating to honest on branch B.
    if stateA["vuln_winner"] and stateA["vuln_winner"].lower() == malicious.lower():
        if winner_vuln_B and winner_vuln_B.lower() == malicious.lower():
            print(" VulnAuction retained malicious winner after reorg ‚Äî THIS IS A PROBLEM.")
        else:
            print(" VulnAuction changed winner after reorg (behavior depends on implementation).")
    else:
        print("‚ÑπÔ∏èVulnAuction branch A winner was not malicious or not set.")

    print("\nDone. You can re-run this script to experiment with different reorg variants.")
    print("Tip: try making branch B include a different malicious reveal or none at all to see other outcomes.")


if __name__ == "__main__":
    main()
